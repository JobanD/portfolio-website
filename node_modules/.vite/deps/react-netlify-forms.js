import {
  require_hoist_non_react_statics_cjs
} from "./chunk-Q2XTACFX.js";
import {
  require_prop_types
} from "./chunk-BZT76YQJ.js";
import {
  __toESM,
  require_react
} from "./chunk-PIOOMT4D.js";

// node_modules/react-netlify-forms/dist/index.modern.js
var import_react3 = __toESM(require_react());

// node_modules/react-google-recaptcha/lib/esm/recaptcha.js
var import_react = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var ReCAPTCHA = function(_React$Component) {
  _inheritsLoose(ReCAPTCHA2, _React$Component);
  function ReCAPTCHA2() {
    var _this;
    _this = _React$Component.call(this) || this;
    _this.handleExpired = _this.handleExpired.bind(_assertThisInitialized(_this));
    _this.handleErrored = _this.handleErrored.bind(_assertThisInitialized(_this));
    _this.handleChange = _this.handleChange.bind(_assertThisInitialized(_this));
    _this.handleRecaptchaRef = _this.handleRecaptchaRef.bind(_assertThisInitialized(_this));
    return _this;
  }
  var _proto = ReCAPTCHA2.prototype;
  _proto.getValue = function getValue() {
    if (this.props.grecaptcha && this._widgetId !== void 0) {
      return this.props.grecaptcha.getResponse(this._widgetId);
    }
    return null;
  };
  _proto.getWidgetId = function getWidgetId() {
    if (this.props.grecaptcha && this._widgetId !== void 0) {
      return this._widgetId;
    }
    return null;
  };
  _proto.execute = function execute() {
    var grecaptcha = this.props.grecaptcha;
    if (grecaptcha && this._widgetId !== void 0) {
      return grecaptcha.execute(this._widgetId);
    } else {
      this._executeRequested = true;
    }
  };
  _proto.executeAsync = function executeAsync() {
    var _this2 = this;
    return new Promise(function(resolve, reject) {
      _this2.executionResolve = resolve;
      _this2.executionReject = reject;
      _this2.execute();
    });
  };
  _proto.reset = function reset() {
    if (this.props.grecaptcha && this._widgetId !== void 0) {
      this.props.grecaptcha.reset(this._widgetId);
    }
  };
  _proto.handleExpired = function handleExpired() {
    if (this.props.onExpired) {
      this.props.onExpired();
    } else {
      this.handleChange(null);
    }
  };
  _proto.handleErrored = function handleErrored() {
    if (this.props.onErrored) {
      this.props.onErrored();
    }
    if (this.executionReject) {
      this.executionReject();
      delete this.executionResolve;
      delete this.executionReject;
    }
  };
  _proto.handleChange = function handleChange(token) {
    if (this.props.onChange) {
      this.props.onChange(token);
    }
    if (this.executionResolve) {
      this.executionResolve(token);
      delete this.executionReject;
      delete this.executionResolve;
    }
  };
  _proto.explicitRender = function explicitRender() {
    if (this.props.grecaptcha && this.props.grecaptcha.render && this._widgetId === void 0) {
      var wrapper = document.createElement("div");
      this._widgetId = this.props.grecaptcha.render(wrapper, {
        sitekey: this.props.sitekey,
        callback: this.handleChange,
        theme: this.props.theme,
        type: this.props.type,
        tabindex: this.props.tabindex,
        "expired-callback": this.handleExpired,
        "error-callback": this.handleErrored,
        size: this.props.size,
        stoken: this.props.stoken,
        hl: this.props.hl,
        badge: this.props.badge
      });
      this.captcha.appendChild(wrapper);
    }
    if (this._executeRequested && this.props.grecaptcha && this._widgetId !== void 0) {
      this._executeRequested = false;
      this.execute();
    }
  };
  _proto.componentDidMount = function componentDidMount() {
    this.explicitRender();
  };
  _proto.componentDidUpdate = function componentDidUpdate() {
    this.explicitRender();
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this._widgetId !== void 0) {
      this.delayOfCaptchaIframeRemoving();
      this.reset();
    }
  };
  _proto.delayOfCaptchaIframeRemoving = function delayOfCaptchaIframeRemoving() {
    var temporaryNode = document.createElement("div");
    document.body.appendChild(temporaryNode);
    temporaryNode.style.display = "none";
    while (this.captcha.firstChild) {
      temporaryNode.appendChild(this.captcha.firstChild);
    }
    setTimeout(function() {
      document.body.removeChild(temporaryNode);
    }, 5e3);
  };
  _proto.handleRecaptchaRef = function handleRecaptchaRef(elem) {
    this.captcha = elem;
  };
  _proto.render = function render() {
    var _this$props = this.props, sitekey = _this$props.sitekey, onChange2 = _this$props.onChange, theme = _this$props.theme, type = _this$props.type, tabindex = _this$props.tabindex, onExpired = _this$props.onExpired, onErrored = _this$props.onErrored, size = _this$props.size, stoken = _this$props.stoken, grecaptcha = _this$props.grecaptcha, badge = _this$props.badge, hl = _this$props.hl, childProps = _objectWithoutPropertiesLoose(_this$props, ["sitekey", "onChange", "theme", "type", "tabindex", "onExpired", "onErrored", "size", "stoken", "grecaptcha", "badge", "hl"]);
    return import_react.default.createElement("div", _extends({}, childProps, {
      ref: this.handleRecaptchaRef
    }));
  };
  return ReCAPTCHA2;
}(import_react.default.Component);
ReCAPTCHA.displayName = "ReCAPTCHA";
ReCAPTCHA.propTypes = {
  sitekey: import_prop_types.default.string.isRequired,
  onChange: import_prop_types.default.func,
  grecaptcha: import_prop_types.default.object,
  theme: import_prop_types.default.oneOf(["dark", "light"]),
  type: import_prop_types.default.oneOf(["image", "audio"]),
  tabindex: import_prop_types.default.number,
  onExpired: import_prop_types.default.func,
  onErrored: import_prop_types.default.func,
  size: import_prop_types.default.oneOf(["compact", "normal", "invisible"]),
  stoken: import_prop_types.default.string,
  hl: import_prop_types.default.string,
  badge: import_prop_types.default.oneOf(["bottomright", "bottomleft", "inline"])
};
ReCAPTCHA.defaultProps = {
  onChange: function onChange() {
  },
  theme: "light",
  type: "image",
  tabindex: 0,
  size: "normal",
  badge: "bottomright"
};

// node_modules/react-async-script/lib/esm/async-script-loader.js
var import_react2 = __toESM(require_react());
var import_prop_types2 = __toESM(require_prop_types());
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _inheritsLoose2(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var SCRIPT_MAP = {};
var idCount = 0;
function makeAsyncScript(getScriptURL, options) {
  options = options || {};
  return function wrapWithAsyncScript(WrappedComponent) {
    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
    var AsyncScriptLoader = function(_Component) {
      _inheritsLoose2(AsyncScriptLoader2, _Component);
      function AsyncScriptLoader2(props, context) {
        var _this;
        _this = _Component.call(this, props, context) || this;
        _this.state = {};
        _this.__scriptURL = "";
        return _this;
      }
      var _proto = AsyncScriptLoader2.prototype;
      _proto.asyncScriptLoaderGetScriptLoaderID = function asyncScriptLoaderGetScriptLoaderID() {
        if (!this.__scriptLoaderID) {
          this.__scriptLoaderID = "async-script-loader-" + idCount++;
        }
        return this.__scriptLoaderID;
      };
      _proto.setupScriptURL = function setupScriptURL() {
        this.__scriptURL = typeof getScriptURL === "function" ? getScriptURL() : getScriptURL;
        return this.__scriptURL;
      };
      _proto.asyncScriptLoaderHandleLoad = function asyncScriptLoaderHandleLoad(state) {
        var _this2 = this;
        this.setState(state, function() {
          return _this2.props.asyncScriptOnLoad && _this2.props.asyncScriptOnLoad(_this2.state);
        });
      };
      _proto.asyncScriptLoaderTriggerOnScriptLoaded = function asyncScriptLoaderTriggerOnScriptLoaded() {
        var mapEntry = SCRIPT_MAP[this.__scriptURL];
        if (!mapEntry || !mapEntry.loaded) {
          throw new Error("Script is not loaded.");
        }
        for (var obsKey in mapEntry.observers) {
          mapEntry.observers[obsKey](mapEntry);
        }
        delete window[options.callbackName];
      };
      _proto.componentDidMount = function componentDidMount() {
        var _this3 = this;
        var scriptURL = this.setupScriptURL();
        var key = this.asyncScriptLoaderGetScriptLoaderID();
        var _options = options, globalName2 = _options.globalName, callbackName2 = _options.callbackName, scriptId = _options.scriptId;
        if (globalName2 && typeof window[globalName2] !== "undefined") {
          SCRIPT_MAP[scriptURL] = {
            loaded: true,
            observers: {}
          };
        }
        if (SCRIPT_MAP[scriptURL]) {
          var entry = SCRIPT_MAP[scriptURL];
          if (entry && (entry.loaded || entry.errored)) {
            this.asyncScriptLoaderHandleLoad(entry);
            return;
          }
          entry.observers[key] = function(entry2) {
            return _this3.asyncScriptLoaderHandleLoad(entry2);
          };
          return;
        }
        var observers = {};
        observers[key] = function(entry2) {
          return _this3.asyncScriptLoaderHandleLoad(entry2);
        };
        SCRIPT_MAP[scriptURL] = {
          loaded: false,
          observers
        };
        var script = document.createElement("script");
        script.src = scriptURL;
        script.async = true;
        for (var attribute in options.attributes) {
          script.setAttribute(attribute, options.attributes[attribute]);
        }
        if (scriptId) {
          script.id = scriptId;
        }
        var callObserverFuncAndRemoveObserver = function callObserverFuncAndRemoveObserver2(func) {
          if (SCRIPT_MAP[scriptURL]) {
            var mapEntry = SCRIPT_MAP[scriptURL];
            var observersMap = mapEntry.observers;
            for (var obsKey in observersMap) {
              if (func(observersMap[obsKey])) {
                delete observersMap[obsKey];
              }
            }
          }
        };
        if (callbackName2 && typeof window !== "undefined") {
          window[callbackName2] = function() {
            return _this3.asyncScriptLoaderTriggerOnScriptLoaded();
          };
        }
        script.onload = function() {
          var mapEntry = SCRIPT_MAP[scriptURL];
          if (mapEntry) {
            mapEntry.loaded = true;
            callObserverFuncAndRemoveObserver(function(observer) {
              if (callbackName2) {
                return false;
              }
              observer(mapEntry);
              return true;
            });
          }
        };
        script.onerror = function() {
          var mapEntry = SCRIPT_MAP[scriptURL];
          if (mapEntry) {
            mapEntry.errored = true;
            callObserverFuncAndRemoveObserver(function(observer) {
              observer(mapEntry);
              return true;
            });
          }
        };
        document.body.appendChild(script);
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        var scriptURL = this.__scriptURL;
        if (options.removeOnUnmount === true) {
          var allScripts = document.getElementsByTagName("script");
          for (var i = 0; i < allScripts.length; i += 1) {
            if (allScripts[i].src.indexOf(scriptURL) > -1) {
              if (allScripts[i].parentNode) {
                allScripts[i].parentNode.removeChild(allScripts[i]);
              }
            }
          }
        }
        var mapEntry = SCRIPT_MAP[scriptURL];
        if (mapEntry) {
          delete mapEntry.observers[this.asyncScriptLoaderGetScriptLoaderID()];
          if (options.removeOnUnmount === true) {
            delete SCRIPT_MAP[scriptURL];
          }
        }
      };
      _proto.render = function render() {
        var globalName2 = options.globalName;
        var _this$props = this.props, asyncScriptOnLoad = _this$props.asyncScriptOnLoad, forwardedRef = _this$props.forwardedRef, childProps = _objectWithoutPropertiesLoose2(_this$props, ["asyncScriptOnLoad", "forwardedRef"]);
        if (globalName2 && typeof window !== "undefined") {
          childProps[globalName2] = typeof window[globalName2] !== "undefined" ? window[globalName2] : void 0;
        }
        childProps.ref = forwardedRef;
        return (0, import_react2.createElement)(WrappedComponent, childProps);
      };
      return AsyncScriptLoader2;
    }(import_react2.Component);
    var ForwardedComponent = (0, import_react2.forwardRef)(function(props, ref) {
      return (0, import_react2.createElement)(AsyncScriptLoader, _extends2({}, props, {
        forwardedRef: ref
      }));
    });
    ForwardedComponent.displayName = "AsyncScriptLoader(" + wrappedComponentName + ")";
    ForwardedComponent.propTypes = {
      asyncScriptOnLoad: import_prop_types2.default.func
    };
    return (0, import_hoist_non_react_statics.default)(ForwardedComponent, WrappedComponent);
  };
}

// node_modules/react-google-recaptcha/lib/esm/recaptcha-wrapper.js
var callbackName = "onloadcallback";
var globalName = "grecaptcha";
function getOptions() {
  return typeof window !== "undefined" && window.recaptchaOptions || {};
}
function getURL() {
  var dynamicOptions = getOptions();
  var hostname = dynamicOptions.useRecaptchaNet ? "recaptcha.net" : "www.google.com";
  return "https://" + hostname + "/recaptcha/api.js?onload=" + callbackName + "&render=explicit";
}
var recaptcha_wrapper_default = makeAsyncScript(getURL, {
  callbackName,
  globalName
})(ReCAPTCHA);

// node_modules/react-google-recaptcha/lib/esm/index.js
var esm_default = recaptcha_wrapper_default;

// node_modules/react-netlify-forms/dist/index.modern.js
function _extends3() {
  _extends3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}
function _objectWithoutPropertiesLoose3(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var _excluded = ["children"];
var NetlifyFormContext = import_react3.default.createContext();
NetlifyFormContext.displayName = "NetlifyFormContext";
var NetlifyFormProvider = function NetlifyFormProvider2(_ref) {
  var children = _ref.children, props = _objectWithoutPropertiesLoose3(_ref, _excluded);
  return import_react3.default.createElement(NetlifyFormContext.Provider, {
    value: _extends3({}, props)
  }, children);
};
function useNetlifyFormContext() {
  return import_react3.default.useContext(NetlifyFormContext);
}
var _excluded$1 = ["label"];
var Honeypot = function Honeypot2(_ref) {
  var _ref$label = _ref.label, label = _ref$label === void 0 ? "Leave the following field empty:" : _ref$label, props = _objectWithoutPropertiesLoose3(_ref, _excluded$1);
  var _useNetlifyFormContex = useNetlifyFormContext(), handleChange = _useNetlifyFormContex.handleChange, honeypotName = _useNetlifyFormContex.honeypotName;
  return import_react3.default.createElement("p", {
    hidden: true
  }, import_react3.default.createElement("label", null, label, " ", import_react3.default.createElement("input", _extends3({
    type: "text"
  }, props, {
    name: honeypotName,
    onChange: handleChange
  }))));
};
var encodeFormData = function encodeFormData2(data) {
  var formData = new FormData();
  for (var _i = 0, _Object$keys = Object.keys(data); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    formData.append(key, data[key]);
  }
  return formData;
};
var isFunction = function isFunction2(x) {
  return typeof x === "function";
};
var isEmptyChildren = function isEmptyChildren2(x) {
  return import_react3.default.Children.count(x) === 0;
};
function NetlifyFormReducer(state, action) {
  var type = action.type, payload = action.payload;
  switch (type) {
    case "CHANGE_FORM_DATA": {
      var _extends22;
      var name = payload.name, value = payload.value, _type = payload.type;
      return _extends3({}, state, {
        values: _extends3({}, state.values, (_extends22 = {}, _extends22[name] = _type !== "checkbox" ? value : payload.checked, _extends22))
      });
    }
    case "RESET_FORM": {
      var initialData = payload;
      return _extends3({}, state, {
        values: initialData
      });
    }
    case "SET_SUCCESS":
      return _extends3({}, state, {
        success: true,
        error: false,
        submitting: false,
        submitted: true
      });
    case "SET_ERROR":
      return _extends3({}, state, {
        success: false,
        error: true,
        submitting: false
      });
    case "SET_SUBMITTING":
      return _extends3({}, state, {
        submitting: true
      });
    case "SET_HONEYPOT_NAME":
      return _extends3({}, state, {
        honeypotName: payload
      });
    case "ENABLE_RECAPTCHA":
      return _extends3({}, state, {
        recaptchaEnabled: payload
      });
    default:
      throw new Error('Action type "' + type + '" is not defined.');
  }
}
var _excluded$2 = ["children"];
var NetlifyFormComponent = function NetlifyFormComponent2(_ref) {
  var children = _ref.children, props = _objectWithoutPropertiesLoose3(_ref, _excluded$2);
  var context = useNetlifyFormContext();
  var formRef = context.formRef, formName = context.formName, formAction = context.formAction, honeypotName = context.honeypotName, recaptchaEnabled = context.recaptchaEnabled, handleSubmit = context.handleSubmit, handleReset = context.handleReset;
  var netlifyProps = {};
  if (honeypotName) {
    netlifyProps["data-netlify-honeypot"] = honeypotName;
  }
  if (recaptchaEnabled) {
    netlifyProps["data-netlify-recaptcha"] = true;
  }
  return import_react3.default.createElement("form", _extends3({
    ref: formRef,
    method: "post",
    name: formName,
    action: formAction,
    onSubmit: handleSubmit,
    onReset: handleReset,
    "data-netlify": true
  }, netlifyProps, props), import_react3.default.createElement("input", {
    type: "hidden",
    name: "form-name",
    value: formName
  }), children ? isFunction(children) ? children(context) : !isEmptyChildren(children) ? children : null : null);
};
var _excluded$3 = ["children", "formProps"];
var useNetlifyForm = function useNetlifyForm2(_ref) {
  var _ref$name = _ref.name, name = _ref$name === void 0 ? "Form" : _ref$name, _ref$action = _ref.action, action = _ref$action === void 0 ? "" : _ref$action, _ref$honeypotName = _ref.honeypotName, honeypotName = _ref$honeypotName === void 0 ? "" : _ref$honeypotName, _ref$enableRecaptcha = _ref.enableRecaptcha, enableRecaptcha = _ref$enableRecaptcha === void 0 ? false : _ref$enableRecaptcha, _ref$onSuccess = _ref.onSuccess, onSuccess = _ref$onSuccess === void 0 ? function() {
  } : _ref$onSuccess, _ref$onFailure = _ref.onFailure, onFailure = _ref$onFailure === void 0 ? function() {
  } : _ref$onFailure;
  var initialValues = {};
  var initialState = {
    success: false,
    error: false,
    submitting: false,
    submitted: false,
    response: null,
    values: initialValues,
    formName: name,
    formAction: action,
    honeypotName,
    recaptchaEnabled: enableRecaptcha,
    recaptchaInvisible: false
  };
  var _React$useReducer = import_react3.default.useReducer(NetlifyFormReducer, initialState), state = _React$useReducer[0], dispatch = _React$useReducer[1];
  var formRef = import_react3.default.useRef(null);
  var recaptchaRef = import_react3.default.useRef(null);
  var handleChange = function handleChange2(_ref2) {
    var _ref2$target = _ref2.target, name2 = _ref2$target.name, value = _ref2$target.value, files = _ref2$target.files;
    dispatch({
      type: "CHANGE_FORM_DATA",
      payload: files != null && files.length > 0 ? {
        name: name2,
        value: files[0]
      } : {
        name: name2,
        value
      }
    });
  };
  var handleReset = function handleReset2() {
    dispatch({
      type: "RESET_FORM",
      payload: initialValues
    });
  };
  var handleSubmit = function handleSubmit2(event, values) {
    if (event === void 0) {
      event = null;
    }
    if (values === void 0) {
      values = {};
    }
    try {
      var _temp4 = function _temp42(_result) {
        if (_exit2)
          return _result;
        dispatch({
          type: "SET_SUBMITTING"
        });
        return Promise.resolve(fetch("/", {
          method: "POST",
          body: encodeFormData(formData)
        })).then(function(response) {
          var context = {
            state,
            formRef,
            recaptchaRef
          };
          if (response.status !== 200) {
            dispatch({
              type: "SET_ERROR"
            });
            return onFailure(response, context);
          }
          dispatch({
            type: "SET_SUCCESS"
          });
          return onSuccess(response, context);
        });
      };
      var _exit2 = false;
      if (event) {
        event.preventDefault();
      }
      var formData = _extends3({
        "form-name": state.formName
      }, values, state.values);
      var _temp5 = function() {
        if (state.recaptchaEnabled) {
          var _temp6 = function _temp62(recaptchaValue) {
            formData["g-recaptcha-response"] = recaptchaValue;
          };
          if (recaptchaRef.current === null) {
            throw new Error("reCAPTCHA is enabled but reference not found, make sure you render the reCAPTCHA-component somewhere.");
          }
          var isRecaptchaInvisible = recaptchaRef.current.props.size === "invisible";
          return isRecaptchaInvisible ? Promise.resolve(recaptchaRef.current.executeAsync()).then(_temp6) : _temp6(recaptchaRef.current.getValue());
        }
      }();
      return Promise.resolve(_temp5 && _temp5.then ? _temp5.then(_temp4) : _temp4(_temp5));
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var setHoneypotName = import_react3.default.useCallback(function(ref) {
    return dispatch({
      type: "SET_HONEYPOT_NAME",
      payload: ref
    });
  }, []);
  var enableRecaptchaHandler = import_react3.default.useCallback(function(enable) {
    return dispatch({
      type: "ENABLE_RECAPTCHA",
      payload: enable
    });
  }, []);
  return _extends3({}, state, {
    handleChange,
    handleSubmit,
    handleReset,
    setHoneypotName,
    enableRecaptcha: enableRecaptchaHandler,
    formRef,
    recaptchaRef
  });
};
var NetlifyForm = function NetlifyForm2(_ref3) {
  var children = _ref3.children, formProps = _ref3.formProps, props = _objectWithoutPropertiesLoose3(_ref3, _excluded$3);
  var context = useNetlifyForm(props);
  return import_react3.default.createElement(NetlifyFormProvider, context, import_react3.default.createElement(NetlifyFormComponent, formProps, children));
};
var _excluded$4 = ["siteKey", "invisible"];
var Recaptcha = function Recaptcha2(_ref) {
  var _ref$siteKey = _ref.siteKey, siteKey = _ref$siteKey === void 0 ? "" : _ref$siteKey, _ref$invisible = _ref.invisible, invisible = _ref$invisible === void 0 ? false : _ref$invisible, passThroughProps = _objectWithoutPropertiesLoose3(_ref, _excluded$4);
  var _useNetlifyFormContex = useNetlifyFormContext(), recaptchaRef = _useNetlifyFormContex.recaptchaRef;
  return import_react3.default.createElement(esm_default, _extends3({}, passThroughProps, {
    sitekey: siteKey,
    ref: recaptchaRef
  }, invisible ? {
    size: "invisible"
  } : {}));
};
export {
  Honeypot,
  NetlifyForm,
  NetlifyFormComponent,
  NetlifyFormContext,
  NetlifyFormProvider,
  Recaptcha,
  useNetlifyForm,
  useNetlifyFormContext
};
//# sourceMappingURL=react-netlify-forms.js.map
